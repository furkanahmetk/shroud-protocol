//! ZK-SNARK proof verification for the withdraw circuit.
//!
//! This module verifies Groth16 proofs generated by snarkjs in the frontend.
//! The proof format is JSON with pi_a, pi_b, pi_c points.

use casper_types::U256;
use odra::prelude::*;
use ark_groth16::{prepare_verifying_key, Groth16, Proof};
use ark_bn254::{Bn254, Fr, Fq, Fq2, G1Affine, G2Affine};
use ark_ff::{BigInteger256, PrimeField};
use ark_snark::SNARK;
use ark_std::vec::Vec;

use crate::vk::get_verification_key;

pub struct Verifier;

impl Verifier {
    /// Verify a Groth16 proof for a withdrawal.
    ///
    /// # Arguments
    /// * `proof_bytes` - JSON-encoded snarkjs proof
    /// * `root` - Merkle tree root
    /// * `nullifier_hash` - Hash of the nullifier
    /// * `recipient` - Address to receive funds (as Casper Address)
    ///
    /// # Returns
    /// `true` if the proof is valid, `false` otherwise
    pub fn verify(
        proof_bytes: &[u8],
        root: U256,
        nullifier_hash: U256,
        recipient: Address,
    ) -> bool {
        // 1. Parse JSON proof from bytes
        let proof_str = match core::str::from_utf8(proof_bytes) {
            Ok(s) => s,
            Err(_) => return false,
        };

        let proof = match parse_snarkjs_proof(proof_str) {
            Some(p) => p,
            None => return false,
        };

        // 2. Get hardcoded verification key
        let vk = get_verification_key();
        let pvk = prepare_verifying_key(&vk);

        // 3. Construct public inputs
        // Order matches circuit: root, nullifierHash, recipient, relayer, fee
        let mut public_inputs: Vec<Fr> = Vec::with_capacity(5);

        // root
        public_inputs.push(u256_to_fr(root));

        // nullifierHash
        public_inputs.push(u256_to_fr(nullifier_hash));

        // recipient - convert Address to Fr
        // Address is a 32-byte account hash, we interpret it as a field element
        public_inputs.push(address_to_fr(recipient));

        // relayer = 0 (not used in current implementation)
        public_inputs.push(Fr::from(0u64));

        // fee = 0 (not used in current implementation)
        public_inputs.push(Fr::from(0u64));

        // 4. Verify the proof
        Groth16::<Bn254>::verify_with_processed_vk(&pvk, &public_inputs, &proof)
            .unwrap_or(false)
    }
}

/// Parse a snarkjs JSON proof into an ark-groth16 Proof.
///
/// snarkjs format:
/// ```json
/// {
///   "pi_a": ["x", "y", "1"],
///   "pi_b": [["x_c0", "x_c1"], ["y_c0", "y_c1"], ["1", "0"]],
///   "pi_c": ["x", "y", "1"]
/// }
/// ```
fn parse_snarkjs_proof(json: &str) -> Option<Proof<Bn254>> {
    // Extract pi_a, pi_b, pi_c arrays from JSON
    let pi_a = extract_g1_point(json, "pi_a")?;
    let pi_b = extract_g2_point(json, "pi_b")?;
    let pi_c = extract_g1_point(json, "pi_c")?;

    Some(Proof { a: pi_a, b: pi_b, c: pi_c })
}

/// Extract a G1 point from JSON by key name.
/// Format: "key": ["x", "y", "1"]
fn extract_g1_point(json: &str, key: &str) -> Option<G1Affine> {
    // Find the key
    let search = alloc::format!("\"{}\"", key);
    let key_pos = json.find(&search)?;

    // Find the opening bracket after the key
    let after_key = &json[key_pos + search.len()..];
    let bracket_pos = after_key.find('[')?;
    let array_start = key_pos + search.len() + bracket_pos;

    // Find matching closing bracket
    let array_content = &json[array_start..];
    let close_pos = find_matching_bracket(array_content)?;
    let array_str = &array_content[1..close_pos]; // Content inside brackets

    // Parse the three values
    let values = extract_string_values(array_str)?;
    if values.len() != 3 {
        return None;
    }

    let x = parse_decimal_to_fq(&values[0])?;
    let y = parse_decimal_to_fq(&values[1])?;
    // z should be "1" for affine representation, we ignore it

    Some(G1Affine::new_unchecked(x, y))
}

/// Extract a G2 point from JSON by key name.
/// Format: "key": [["x_c0", "x_c1"], ["y_c0", "y_c1"], ["z_c0", "z_c1"]]
fn extract_g2_point(json: &str, key: &str) -> Option<G2Affine> {
    // Find the key
    let search = alloc::format!("\"{}\"", key);
    let key_pos = json.find(&search)?;

    // Find the opening bracket after the key
    let after_key = &json[key_pos + search.len()..];
    let bracket_pos = after_key.find('[')?;
    let array_start = key_pos + search.len() + bracket_pos;

    // Find matching closing bracket
    let array_content = &json[array_start..];
    let close_pos = find_matching_bracket(array_content)?;
    let outer_str = &array_content[1..close_pos];

    // Extract three sub-arrays
    let sub_arrays = extract_nested_arrays(outer_str)?;
    if sub_arrays.len() != 3 {
        return None;
    }

    // Parse x coordinate (Fq2)
    let x_vals = extract_string_values(&sub_arrays[0])?;
    if x_vals.len() != 2 {
        return None;
    }
    let x = Fq2::new(
        parse_decimal_to_fq(&x_vals[0])?,
        parse_decimal_to_fq(&x_vals[1])?,
    );

    // Parse y coordinate (Fq2)
    let y_vals = extract_string_values(&sub_arrays[1])?;
    if y_vals.len() != 2 {
        return None;
    }
    let y = Fq2::new(
        parse_decimal_to_fq(&y_vals[0])?,
        parse_decimal_to_fq(&y_vals[1])?,
    );

    // z should be ["1", "0"] for affine, we ignore it

    Some(G2Affine::new_unchecked(x, y))
}

/// Find the position of the matching closing bracket.
fn find_matching_bracket(s: &str) -> Option<usize> {
    let mut depth = 0;
    for (i, c) in s.chars().enumerate() {
        match c {
            '[' => depth += 1,
            ']' => {
                depth -= 1;
                if depth == 0 {
                    return Some(i);
                }
            }
            _ => {}
        }
    }
    None
}

/// Extract nested arrays from a string like: ["a","b"], ["c","d"], ["e","f"]
fn extract_nested_arrays(s: &str) -> Option<Vec<String>> {
    let mut result = Vec::new();
    let mut depth = 0;
    let mut start = None;

    for (i, c) in s.chars().enumerate() {
        match c {
            '[' => {
                if depth == 0 {
                    start = Some(i);
                }
                depth += 1;
            }
            ']' => {
                depth -= 1;
                if depth == 0 {
                    if let Some(st) = start {
                        result.push(s[st+1..i].to_string());
                    }
                    start = None;
                }
            }
            _ => {}
        }
    }

    Some(result)
}

/// Extract string values from a JSON array content like: "123", "456"
fn extract_string_values(s: &str) -> Option<Vec<String>> {
    let mut result = Vec::new();
    let mut in_string = false;
    let mut current = String::new();

    for c in s.chars() {
        match c {
            '"' => {
                if in_string {
                    result.push(current.clone());
                    current.clear();
                }
                in_string = !in_string;
            }
            _ if in_string => {
                current.push(c);
            }
            _ => {}
        }
    }

    Some(result)
}

/// Parse a decimal string to Fq field element.
fn parse_decimal_to_fq(s: &str) -> Option<Fq> {
    // Parse decimal string to BigInteger256
    let bigint = parse_decimal_to_bigint(s)?;
    Some(Fq::from_bigint(bigint)?)
}

/// Parse a decimal string to BigInteger256.
fn parse_decimal_to_bigint(s: &str) -> Option<BigInteger256> {
    // Parse decimal string manually
    // We need to handle large numbers that don't fit in u64
    let s = s.trim();
    if s.is_empty() {
        return None;
    }

    // Use the fact that we can accumulate digit by digit
    // result = result * 10 + digit
    let mut result = BigInteger256::new([0u64; 4]);

    for c in s.chars() {
        let digit = c.to_digit(10)? as u64;

        // result = result * 10
        result = mul_by_10(result)?;

        // result = result + digit
        result = add_u64(result, digit)?;
    }

    Some(result)
}

/// Multiply a BigInteger256 by 10.
fn mul_by_10(a: BigInteger256) -> Option<BigInteger256> {
    // a * 10 = a * 8 + a * 2 = (a << 3) + (a << 1)
    let a8 = shl(a, 3)?;
    let a2 = shl(a, 1)?;
    add_bigint(a8, a2)
}

/// Shift left by n bits.
fn shl(a: BigInteger256, n: u32) -> Option<BigInteger256> {
    let mut result = a;
    for _ in 0..n {
        // Check if top bit is set (would overflow)
        if result.0[3] & 0x8000_0000_0000_0000 != 0 {
            return None; // Overflow
        }

        // Shift each limb
        let carry0 = result.0[0] >> 63;
        let carry1 = result.0[1] >> 63;
        let carry2 = result.0[2] >> 63;

        result.0[0] <<= 1;
        result.0[1] = (result.0[1] << 1) | carry0;
        result.0[2] = (result.0[2] << 1) | carry1;
        result.0[3] = (result.0[3] << 1) | carry2;
    }
    Some(result)
}

/// Add two BigInteger256 values.
fn add_bigint(a: BigInteger256, b: BigInteger256) -> Option<BigInteger256> {
    let mut result = [0u64; 4];
    let mut carry = 0u64;

    for i in 0..4 {
        let (sum1, c1) = a.0[i].overflowing_add(b.0[i]);
        let (sum2, c2) = sum1.overflowing_add(carry);
        result[i] = sum2;
        carry = (c1 as u64) + (c2 as u64);
    }

    if carry != 0 {
        return None; // Overflow
    }

    Some(BigInteger256::new(result))
}

/// Add a u64 to a BigInteger256.
fn add_u64(a: BigInteger256, b: u64) -> Option<BigInteger256> {
    let b_big = BigInteger256::new([b, 0, 0, 0]);
    add_bigint(a, b_big)
}

/// Convert a Casper U256 to an ark Fr field element.
fn u256_to_fr(val: U256) -> Fr {
    // U256 is stored as little-endian limbs
    let mut bytes = [0u8; 32];
    val.to_little_endian(&mut bytes);

    // Use from_le_bytes_mod_order to properly reduce values >= field modulus
    // This matches how the frontend/circuit handles large values
    Fr::from_le_bytes_mod_order(&bytes)
}

/// Convert a Casper Address to an ark Fr field element.
///
/// The frontend computes: BigInt('0x' + accountHashHex)
/// where accountHashHex is the 32-byte account hash in hex.
/// This is a big-endian interpretation that may exceed the field modulus.
fn address_to_fr(addr: Address) -> Fr {
    // Address contains an account hash which is 32 bytes
    // We need to convert it to a field element the same way the frontend does

    // Get the raw bytes from the address
    let hash_bytes = match addr {
        Address::Account(account_hash) => {
            // AccountHash contains the 32-byte hash
            account_hash.value()
        }
        Address::Contract(contract_package_hash) => {
            // ContractPackageHash also contains 32 bytes
            contract_package_hash.value()
        }
    };

    // Frontend: BigInt('0x' + hex) - interprets as big-endian number
    // Use from_be_bytes_mod_order to properly reduce values >= field modulus
    // This matches how snarkjs/circuits handle large values (automatic mod p)
    Fr::from_be_bytes_mod_order(&hash_bytes)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_decimal() {
        let result = parse_decimal_to_bigint("123456789");
        assert!(result.is_some());
        let bigint = result.unwrap();
        assert_eq!(bigint.0[0], 123456789);
        assert_eq!(bigint.0[1], 0);
        assert_eq!(bigint.0[2], 0);
        assert_eq!(bigint.0[3], 0);
    }

    #[test]
    fn test_parse_large_decimal() {
        // Test with a number larger than u64::MAX
        let result = parse_decimal_to_bigint("18446744073709551616"); // 2^64
        assert!(result.is_some());
        let bigint = result.unwrap();
        assert_eq!(bigint.0[0], 0);
        assert_eq!(bigint.0[1], 1);
    }

    #[test]
    fn test_extract_string_values() {
        let input = r#""123", "456", "1""#;
        let result = extract_string_values(input);
        assert!(result.is_some());
        let values = result.unwrap();
        assert_eq!(values.len(), 3);
        assert_eq!(values[0], "123");
        assert_eq!(values[1], "456");
        assert_eq!(values[2], "1");
    }
}
