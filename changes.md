# Shroud Protocol: Recent Changes & Architecture Update

This document details the critical fixes and architectural changes implemented to resolve the **"UnknownRoot" (User error: 4)** on-chain failure, improve **Wallet Stability**, and handle **Concurrent Deposits** correctly.

---

## 1. ðŸŒ³ Merkle Tree & Circuit Verification Fixes

**Issue:** withdrawals were failing on-chain with `User error: 4` (UnknownRoot).
**Root Cause:** The `snarkjs` proof generated by the frontend was valid for the frontend's computed Merkle Root, but that Root did not match any of the roots stored in the Smart Contract's history. This was due to two fundamental mismatches:
1.  **Zero Value Mismatch:** The contract uses `0` for empty leaves/nodes at *all* levels. Our initial frontend implementation used precomputed hashes of zeros (e.g., `hash(0,0)`), leading to completely different tree roots.
2.  **Incremental Algorithm Mismatch:** The contract uses a specific "Incremental Merkle Tree" algorithm using `filled_subtrees`. This algorithm produces a tailored root at each insertion step. A standard "full tree" build produces different roots for the same set of leaves. Furthermore, the path for leaf N is valid *only* for the root generated at insertion N. Using the *latest* root with an *older* path causes verification failure.

**Solution:**
*   **Rewrote `MerkleTree` Class:** Completely re-implemented `src/utils/crypto.ts` to match the contract's logic line-by-line.
    *   **Incremental Insertion:** Implemented `filled_subtrees` logic to replicate how the contract updates roots.
    *   **Root-Path Pairing:** The class now caches the Merkle Path *at the moment of insertion* and pairs it with the *specific root* generated at that moment.
    *   **Unified Fallback:** Updated `getPath()` to return `{ path, root }`. The `Withdraw` component now uses this paired `path.root` instead of the `tree.getRoot()` (latest), ensuring the proof matches a root that actually exists in the contract's history (last 30 roots).

---

## 2. ðŸ’¸ Deposit Process Updates: "Pending" Leaf Index

**Observation:** The downloaded secret JSON now shows `"leafIndex": "pending"`.

**Why?**
In a decentralized system, multiple users can deposit at the same time ("Concurrent Deposits").
1.  **Race Condition:** If User A and User B send transactions simultaneously, we cannot know for sure which one will be processed first by the block producer.
2.  **Static Indexing Failed:** Previously, we assigned `leafIndex` based on the local count of deposits *before* sending the transaction. If User B's transaction hit the chain before User A's, User A's local index would be wrong. A wrong index leads to a wrong Merkle Path, which guarantees a failed withdrawal.

**The Fix:**
*   **Mark as Pending:** We no longer assign a fixed index at the moment of deposit. We mark it as `"pending"`.
*   **Commitment is Key:** The `commitment` (hash of nullifier + secret) is the unique identifier for the deposit. It is invariant regardless of insertion order.

---

## 3. ðŸ”„ Withdrawal Process: Dynamic Index Resolution

**Question:** "How do you handle that indexing?"

**Answer:** We move the responsibility of finding the index to the **Withdrawal Phase**, where we have perfect information.

**Workflow at Withdrawal:**
1.  **Fetch All Commitments:** The frontend connects to the blockchain (via Casper Explorer API) and downloads the full list of `Deposit` events.
2.  **Find Our Commitment:** We search this authoritative on-chain list for our specific `commitment` (from the secret JSON).
    *   *Example:* If our commitment is found at position 5 of the list, then our `leafIndex` is `5`.
3.  **Correctness Guaranteed:** Because this list comes from the finalized blockchain state, the index we find is guaranteed to be correct.
4.  **Rebuild Tree:** We re-insert all these fetched commitments into our local (fixed) `MerkleTree` class. This reconstructs the exact state of the contract's tree.
5.  **Generate Proof:** We generate the Merkle Path for our determined index (e.g., 5) and the root associated with it.

---

## 4. ðŸ”’ Wallet Stability: partial "SigningLock"

**Issue:** Users experienced failures where the wallet signing window would become unresponsive or the app would error during signing.
**Cause:** The application runs background tasks (polling for balance updates every 5s, syncing commitments every 60s). If these network requests fired *while* the Casper Wallet popup was open and awaiting a signature, the wallet extension (or the browser connection to it) could conflict or timeout.

**The Fix:**
*   **Global SigningLock:** Implemented `src/utils/signingLock.ts`.
*   **Pause Background Work:**
    *   When you click "Sign", we `acquire()` the lock.
    *   `useWallet` (balance check) and `CommitmentContext` (sync poll) check this lock before reacting. If locked, they **skip** their work.
    *   Once signing completes (or is cancelled), the lock is `release()`d, and background updates resume.
*   **Result:** A clean, uninterrupted channel for the wallet to communicate with the user and the page.

---

## 5. ðŸ›  Casper SDK & Serialization Compatability

**Issue:** "Arg not valid" errors in Casper Wallet.
**Cause:** The Casper Wallet extension expects a legacy JSON format for contract arguments (`CLValue`s), but the newer `casper-js-sdk` v5 produces a different internal structure.
**Fix:**
*   **Manual Serialization:** We created a helper `deployToLegacyJson` in `useWallet.ts` (and `utils/casper.ts`) that manually formats the transaction arguments into the exact JSON structure the wallet extension requires.
*   **Version Patching:** Specifically patched the `StoredVersionedContractByHash` argument, which was missing a `version` field (wallet expects `null` explicitly, SDK was sending `undefined`).

---

### Summary Checklist for a Successful Protocol Run:

1.  **Deposit:** User generates secret. `leafIndex` is "pending". Transaction sent.
2.  **Wait:** Transaction confirms on-chain.
3.  **Withdraw:**
    *   Frontend syncs with chain, finding the `commitment`.
    *   Correct `leafIndex` is resolved.
    *   Merkle Tree is rebuilt locally.
    *   Path and Root (from insertion time) are retrieved.
    *   ZK Proof generated against that specific Root.
    *   Withdrawal transaction sent and verified by contract.
